# 타입스크립트

## Type Widening (타입 넓히기)
자바스크립트의 런타임: 모든 변수는 유일한 값   
타입스크립트의 정적 분석: 모든 변수는 가능한 값들의 집합(타입)

대입된 값을 **할당 가능한 값들의 집합으로 유추**해야하는 것

### 왜 문제일까?
let coffeeName의 할당 시점에 **넓히기**가 동작하여 string으로 추론되었다.
넓히기가 진행될 때 주어진 값으로 추론 가능한 타입이 **여러 개**가 될 수 있다.

```typescript
const whatIsType = ['x', 1];

//위 변수는 아래 타입으로 추론될 수 있다.
type Able1 = ('x' | 1)[];
type Able2 = ['x', 1];
type Able3 = [string, number];
type Able4 = readonly [string, number];
type Able5 = (string | number)[];
type Able6 = readonly (string | number)[];
type Able7 = [any, any];
type Able8 = any[];
```

## Type Narrowing (타입 좁히기)

```typescript
const $ = (selector: string) => document.querySelector(selector);

const $button0 = $('button') as Node;
const $button1 = $('button') as Element;

$button0.parentElement;
$button1.form; // 에러
```

### 타입의 범위를 좁히는 방법?
1. if문으로 null과 undefined 체크
2. instances 사용
3. 속성 체크 (in 연산자)
4. 태그된 유니온과 구별된 유니온 활용
  ```typescript
    type Americano = number;
    type Espresso = string;
    type AmericanoOption = number;
    type EspressoOption = string;

    interface AmericanoOrder {
      coffee: Americano;
      option: AmericanoOption;
      unique: boolean; // 구별된 유니온 설정 추가
    }
    interface EspressoOrder {
      coffee: Espresso;
      option: EspressoOption;
    }

    // 태그된 유니온
    type Order = AmericanoOrder | EspressoOrder;

    // 구별된 유니온
    function make(order: Order) {
      if('unique' in order) return order;
    }
  ```
5. 사용자 정의 타입 가드 사용 (is 연산자)
